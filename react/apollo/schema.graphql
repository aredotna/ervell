# Autogenerated input type of AcceptChannelTransfer
input AcceptChannelTransferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  token: String!
}

# Autogenerated return type of AcceptChannelTransfer
type AcceptChannelTransferPayload {
  channel_transfer_request: ChannelTransferRequest

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AcceptInvitation
input AcceptInvitationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
  first_name: String!
  invitation_token: String!
  last_name: String!
  password: String!
  password_confirmation: String!
  receive_newsletter: Boolean
  receive_tips_emails: Boolean
}

# Autogenerated return type of AcceptInvitation
type AcceptInvitationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Autogenerated input type of AddChannelMembers
input AddChannelMembersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  members: [ChannelMemberInput]!
}

# Autogenerated return type of AddChannelMembers
type AddChannelMembersPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AddCollaborator
input AddCollaboratorInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  user_ids: [ID]!
}

# Autogenerated return type of AddCollaborator
type AddCollaboratorPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AddCreditCard
input AddCreditCardInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  default_source: Boolean
  token: String!
}

# Autogenerated return type of AddCreditCard
type AddCreditCardPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  customer: Customer
}

# Autogenerated input type of AddGroupUsers
input AddGroupUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  user_ids: [ID]!
}

# Autogenerated return type of AddGroupUsers
type AddGroupUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# An attachment block
type Attachment implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  file_extension: String
  file_url: String
  href: String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# Providers for external authentication
enum AuthenticatedServiceProvider {
  TWITTER
}

# An authorized external service provider
type Authentication implements Model {
  contacts(page: Int = 1, per: Int = 50): [User]
  created_at(format: String, relative: Boolean): String
  id: Int
  provider: String
  uid: String
  updated_at(format: String, relative: Boolean): String
}

# Avatar sizes
enum AvatarVersion {
  LARGE
  MEDIUM
  SMALL
}

# Possible connectables for a new connection
enum BaseConnectableTypeEnum {
  BLOCK
  CHANNEL
}

# Fields common to all Block types
interface Block {
  can: BlockCan
  counts: BlockCounts
}

# The actions that the CurrentUser can perform on the Block
type BlockCan {
  manage: Boolean
  read: Boolean
}

type BlockCounts {
  channels: Int
  comments: Int
}

# Autogenerated input type of CancelChannelTransfer
input CancelChannelTransferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of CancelChannelTransfer
type CancelChannelTransferPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CancelPremiumSubscription
input CancelPremiumSubscriptionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CancelPremiumSubscription
type CancelPremiumSubscriptionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# A single channel
type Channel implements ConnectableInterface & Followable & Model & Mutable {
  blocks(direction: Directions = ASC, page: Int = 1, per: Int = 25, sort_by: Sorts = POSITION, type: ConnectableTypeEnum = null, user_id: ID = null): [Connectable] @deprecated(reason: "Use `blokks` until this can be replaced with it")
  blokks(direction: Directions = ASC, page: Int = 1, per: Int = 25, sort_by: Sorts = POSITION, type: ConnectableTypeEnum = null, user_id: ID = null): [Konnectable]
  can: ChannelCan
  channels: [Channel]
  collaborators: [User] @deprecated(reason: "This only returns Users. Use `members` field instead")
  comments(direction: Directions = ASC): [Comment]
  connected_to_channels: [Channel]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  counts: ChannelCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  followers(page: Int = 1, per: Int = 1): [User]
  href: String
  id: Int
  is_collaboration: Boolean
  is_followed: Boolean
  is_muted: Boolean
  is_open: Boolean @deprecated(reason: "Use `visibility`")
  is_pending_transfer: Boolean
  is_published: Boolean @deprecated(reason: "Use `visibility`")
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  members: [Member]
  memberships: [ChannelMembership]
  owner: ChannelOwner
  share: ChannelShare
  share_id: String
  slug: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  transfer_request: ChannelTransferRequest
  type: String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# The actions that the CurrentUser can perform on the Channel
type ChannelCan {
  add_to: Boolean
  connect: Boolean
  destroy: Boolean
  export: Boolean
  follow: Boolean
  manage: Boolean
  manage_collaborators: Boolean
  mute: Boolean
  read: Boolean
  transfer: Boolean
  update: Boolean
}

type ChannelCounts {
  blocks: Int
  channels: Int
  collaborators: Int
  connected_to_channels: Int
  contents: Int
  followers: Int
}

input ChannelMemberInput {
  id: ID!
  type: MemberTypes = USER
}

# A membership defining the relationship between Channels and Members (Users or Groups)
type ChannelMembership implements Model {
  can: ChannelMembershipCan
  created_at(format: String, relative: Boolean): String
  id: Int
  member: Member
  updated_at(format: String, relative: Boolean): String
}

# The actions that the CurrentUser can perform on the ChannelMembership
type ChannelMembershipCan {
  manage: Boolean
}

union ChannelOwner = Group | User

enum ChannelOwnerTypeEnum {
  GROUP
  USER
}

# Properties needed to share channels externally
type ChannelShare {
  facebook_url: String
  twitter_url: String
  url: String
}

# A request to transfer the ownership of a channel to a new user
type ChannelTransferRequest implements Model {
  channel: Channel
  created_at(format: String, relative: Boolean): String
  id: Int
  is_recipient_member: Boolean
  is_user_to_member: Boolean @deprecated(reason: "User => Owner: use `is_recipient_member` field")
  recipient: ChannelOwner
  sender: ChannelOwner
  updated_at(format: String, relative: Boolean): String
  user_from: User @deprecated(reason: "User => Owner: use `sender` field")
  user_to: User @deprecated(reason: "User => Owner: use recipient field")
}

# Privacy states for a channel
enum ChannelVisibility {
  CLOSED
  PRIVATE
  PUBLIC
}

# Autogenerated input type of ClearNotifications
input ClearNotificationsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  confirm: Boolean!
}

# Autogenerated return type of ClearNotifications
type ClearNotificationsPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# A single comment
type Comment implements Model {
  body(truncate: Int): String
  commentable: Commentable
  created_at(format: String, relative: Boolean): String
  id: Int
  updated_at(format: String, relative: Boolean): String
  user: User
}

# Union of objects that can be commented on
union Commentable = Attachment | Embed | Image | Link | Text

# A block or a channel
type Connectable implements ConnectableInterface & Model & Mutable {
  can: ConnectableCan @deprecated(reason: "Use specific type cans")
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  href: String
  id: Int
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# The actions that the CurrentUser can perform on the Connectable
type ConnectableCan {
  manage: Boolean
  read: Boolean
}

# Fields common to models that can be connected
interface ConnectableInterface {
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  description(format: Format, no_links: Boolean = false): String
  href: String
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  user: User
  visibility: String
}

# Connectable attributes specific to its class
union ConnectableKind = Attachment | Channel | Embed | Image | Link | PendingBlock | Text

type ConnectableSource {
  provider_name: String
  provider_url: String
  title: String
  url: String
}

# Connectable types
enum ConnectableTypeEnum {
  ATTACHMENT
  BLOCK
  CHANNEL
  EMBED
  IMAGE
  LINK
  TEXT
}

# A connection
type Connection implements Model {
  can: ConnectionCan
  channel: Channel
  connectable: Connectable
  created_at(format: String, relative: Boolean): String
  id: Int
  position: Int
  updated_at(format: String, relative: Boolean): String
  user: User
}

# The actions that the CurrentUser can perform on the Connection
type ConnectionCan {
  create: Boolean
  destroy: Boolean
  manage: Boolean
}

type Coupon {
  amount_off: Int
  code: String
  created_at(format: String, relative: Boolean): String
  currency: String
  description: String
  duration: String
  duration_in_months: String
  id: String
  is_valid: Boolean
  percent_off: Int
  redeem_by(format: String, relative: Boolean): String
}

# Autogenerated input type of CreateAuthenticatedService
input CreateAuthenticatedServiceInput {
  avatar_url: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  provider: AuthenticatedServiceProvider = TWITTER
  secret: String!
  token: String!
  uid: String!
}

# Autogenerated return type of CreateAuthenticatedService
type CreateAuthenticatedServicePayload {
  authenticated_service: Authentication

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateBlock
input CreateBlockInput {
  channel_ids: [ID]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  content: String
  description: String
  original_source_title: String
  original_source_url: String
  source_url: String
  title: String
}

# Autogenerated return type of CreateBlock
type CreateBlockPayload {
  block: Connectable
  channels: [Channel]

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateChannel
input CreateChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  group_id: ID
  title: String!
  visibility: ChannelVisibility = CLOSED
}

# Autogenerated return type of CreateChannel
type CreateChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateComment
input CreateCommentInput {
  block_id: ID!
  body: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateComment
type CreateCommentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  comment: Comment
}

# Autogenerated input type of CreateConnection
input CreateConnectionInput {
  channel_ids: [ID]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectable_id: ID!
  connectable_type: BaseConnectableTypeEnum!
}

# Autogenerated return type of CreateConnection
type CreateConnectionPayload {
  channels: [Channel]

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectable: Connectable
  connections: [Connection]
  konnectable: Konnectable
}

# Autogenerated input type of CreateGroup
input CreateGroupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  name: String!
}

# Autogenerated return type of CreateGroup
type CreateGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Autogenerated input type of CreateUserMessageChannel
input CreateUserMessageChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of CreateUserMessageChannel
type CreateUserMessageChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

type CreditCard {
  brand: String
  exp_month: String
  exp_year: String
  id: String
  last4: String
}

# Your account customer data
type Customer implements Model {
  created_at(format: String, relative: Boolean): String
  credit_cards: [CreditCard]
  current_period_end_at(format: String, relative: Boolean): String
  current_period_start_at(format: String, relative: Boolean): String
  default_credit_card: CreditCard
  external_id: String
  id: Int
  is_canceled: Boolean
  is_delinquent: Boolean
  is_lifetime: Boolean
  is_premium: Boolean
  plan: Plan
  plan_id: String
  status: String
  subscription: PremiumSubscription
  upcoming_invoice(coupon_code: String, plan_id: String): Invoice
  updated_at(format: String, relative: Boolean): String
}

# A single deed
type Deed implements Model {
  action: String
  bulletin_id: ID
  connector: String
  created_at(format: String, relative: Boolean): String
  id: Int
  is_read: Boolean
  item: DeedKind
  item_title(truncate: Int): String
  owner: DeedOwner
  parent: DeedKind
  target: DeedKind
  updated_at(format: String, relative: Boolean): String
  user: User
}

# A group of deeds
type DeedGroup {
  action: String
  are_all_read: Boolean
  connector: String
  created_at(format: String, relative: Boolean): String
  deeds: [Deed]
  ids: [ID]
  is_single: Boolean
  item: DeedKind
  item_phrase(truncate: Int): String
  items: [DeedKind] @deprecated(reason: "Use `objects`")
  key: String
  length: Int
  object: DeedKind @deprecated(reason: "Use `item`")
  object_phrase(truncate: Int): String @deprecated(reason: "Use `item_phrase`")
  objects: [DeedKkind]
  owner: DeedOwner
  target: DeedKind
  target_phrase(truncate: Int): String
  user: User
  verb: String @deprecated(reason: "Use `action`")
}

# Deed item, target, or parent
union DeedKind = Channel | Comment | Connectable | Group | Null | User

# Deed item, target, or parent
union DeedKkind = Attachment | Channel | Comment | Embed | Group | Image | Link | Text | User

union DeedOwner = Group | User

# Autogenerated input type of DeleteAuthenticatedService
input DeleteAuthenticatedServiceInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteAuthenticatedService
type DeleteAuthenticatedServicePayload {
  authenticated_service: Authentication

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of DeleteChannel
input DeleteChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteChannel
type DeleteChannelPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Autogenerated input type of DeleteConnection
input DeleteConnectionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteConnection
type DeleteConnectionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Autogenerated input type of DeleteGroup
input DeleteGroupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteGroup
type DeleteGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Directions to sort blocks
enum Directions {
  ASC
  DESC
}

# An embed block
type Embed implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  embed_html: String
  href: String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  source_url: String
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# Autogenerated input type of ExportChannel
input ExportChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  format: ExportFormats!
  id: ID!
}

# Autogenerated return type of ExportChannel
type ExportChannelPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

enum ExportFormats {
  HTML
  PDF
  ZIP
}

# A feed
type Feed {
  deeds: [Deed]
  groups: [DeedGroup]
  total: Int
}

# Autogenerated input type of Follow
input FollowInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  type: FollowableTypeEnum!
}

# Autogenerated return type of Follow
type FollowPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  followable: FollowableType
}

# Fields common to models that can be followed
interface Followable {
  followers(page: Int = 1, per: Int = 1): [User]
  is_followed: Boolean
}

# Followable object
union FollowableType = Channel | Group | User

# Types of followable objects
enum FollowableTypeEnum {
  CHANNEL
  GROUP
  USER
}

# Ways to format a markdown field
enum Format {
  HTML
  MARKDOWN
}

# A Group of Users
type Group implements Followable & Model {
  avatar(size: AvatarVersion): String
  can: GroupCan
  channels(page: Int = 1, per: Int = 1): [Channel]

  # Special channel field that eager loads all the owner and does not do pagination
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]
  counts: GroupCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  followers(page: Int = 1, per: Int = 1): [User]
  href: String
  id: Int
  initials: String
  is_followed: Boolean
  manageable_user_ids: [Int]
  memberships: [GroupMembership]
  name: String
  slug: String
  updated_at(format: String, relative: Boolean): String
  user: User
  users: [User]
  visibility: String
}

# The actions that the CurrentUser can perform on the Group
type GroupCan {
  add_to: Boolean
  destroy: Boolean
  follow: Boolean
  manage: Boolean
  manage_users: Boolean
  update: Boolean
}

type GroupCounts {
  channels: Int
  followers: Int
  users: Int
}

# A membership defining the relationship between Groups and Users
type GroupMembership implements Model {
  can: GroupMembershipCan
  created_at(format: String, relative: Boolean): String
  id: Int
  updated_at(format: String, relative: Boolean): String
  user: User
}

# The actions that the CurrentUser can perform on the GroupMembership
type GroupMembershipCan {
  manage: Boolean
}

union Identifiable = Group | User

# An object which exposes and names Users and Groups
type Identity {
  identifiable: Identifiable!
  name: String!
  slug: String!
}

# An image block
type Image implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  href: String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# Image sizes
enum ImageVersion {
  DISPLAY
  LARGE
  ORIGINAL
  SQUARE
  THUMB
}

type IndexedChannels {
  channels: [Channel]
  key: String
}

enum IndexedChannelsTypes {
  COLLABORATION
  OWN
}

# Autogenerated input type of InitiateChannelTransfer
input InitiateChannelTransferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  owner_id: ID
  owner_type: ChannelOwnerTypeEnum
  user_id: ID
}

# Autogenerated return type of InitiateChannelTransfer
type InitiateChannelTransferPayload {
  channel_transfer_request: ChannelTransferRequest

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of InviteCollaborator
input InviteCollaboratorInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
}

# Autogenerated return type of InviteCollaborator
type InviteCollaboratorPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of InviteGroupUsers
input InviteGroupUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  emails: [String!]!
  id: ID!
}

# Autogenerated return type of InviteGroupUsers
type InviteGroupUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Autogenerated input type of InviteUsers
input InviteUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  emails: [String!]!
}

# Autogenerated return type of InviteUsers
type InviteUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  users: [User]
}

# An invited user
type Invitee implements Model & UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan

  # Special channel field that eager loads all the owner and does not do pagination
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]
  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Connectable]
  created_at(format: String, relative: Boolean): String
  email: String
  first_name: String
  following(page: Int = 1, per: Int = 1): [FollowableType]
  groups(page: Int = 1, per: Int = 1): [Group]
  hidden_email: String
  href(absolute: Boolean = false): String
  id: Int
  initials: String
  is_indexable: Boolean
  is_investor: Boolean
  is_me: Boolean
  is_premium: Boolean
  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]
  last_name: String
  name: String
  slug: String
  updated_at(format: String, relative: Boolean): String
}

type Invoice {
  next_payment_attempt_at(format: String, relative: Boolean): String

  # USD cents
  subtotal: Int

  # USD cents
  total: Int
}

union Konnectable = Attachment | Channel | Embed | Image | Link | PendingBlock | Text

# A link block
type Link implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  href: String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  source_url: String
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# Autogenerated input type of Login
input LoginInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
  password: String!
}

# Autogenerated return type of Login
type LoginPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# The current user
type Me implements Model & UserInterface {
  authenticated_service(provider: AuthenticatedServiceProvider = TWITTER): Authentication
  authentication_token: String
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan

  # Special channel field that eager loads all the owner and does not do pagination
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]
  connection_search(direction: Directions = DESC, per: Int = 5, q: String = null): [Channel]
  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Connectable]
  counts: MeCounts
  created_at(format: String, relative: Boolean): String
  customer: Customer
  email: String
  feed(end: String = "-inf", limit: Int = 50, offset: Int = 0, start: String = "+inf", type: String = "User"): Feed
  first_name: String
  flag(name: String!): Boolean
  flags: MeFlags
  following(page: Int = 1, per: Int = 1): [FollowableType]
  groups(page: Int = 1, per: Int = 1): [Group]
  hidden_email: String
  home_path: String
  href(absolute: Boolean = false): String
  id: Int
  initials: String
  is_confirmed: Boolean
  is_exceeding_private_connections_limit: Boolean
  is_indexable: Boolean
  is_investor: Boolean
  is_me: Boolean
  is_pending_confirmation: Boolean
  is_pending_reconfirmation: Boolean
  is_premium: Boolean
  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]
  last_name: String
  name: String
  notifications(end: String = "-inf", limit: Int = 50, offset: Int = 0, start: String = "+inf"): Feed
  plan: String
  plans: [Plan]

  # Manifest for uploading new files to S3
  policy: Policy
  post_address: String
  recent_connections(per: Int = 1): [Channel]
  settings: MeSettings
  slug: String
  unconfirmed_email: String
  updated_at(format: String, relative: Boolean): String
}

type MeCounts implements UserCountsInterface {
  blocks: Int
  channels: Int
  connections: Int
  followers: Int
  following: Int
  groups: Int
  notifications: Int
  private_connections: Int
  private_connections_limit: Int
}

input MeFlagInput {
  name: String!
  value: Boolean!
}

type MeFlags {
  has_seen_feed_connect_twitter: Boolean
}

# Flag keys
enum MeFlagsEnum {
  HAS_SEEN_FEED_CONNECT_TWITTER
}

type MeSettings {
  exclude_from_indexes: Boolean
  receive_email: String
  receive_newsletter: Boolean
  receive_tips_emails: Boolean
  show_tour: Boolean
}

# Union of Channel members
union Member = Group | User

# Member types
enum MemberTypes {
  GROUP
  USER
}

# Fields common to all models
interface Model {
  created_at(format: String, relative: Boolean): String
  id: Int
  updated_at(format: String, relative: Boolean): String
}

# Fields common to models that can be muted
interface Mutable {
  is_muted: Boolean
}

# Mute-able object
union MutableType = Channel | Connectable

# Objects that can be muted
enum MutableTypeEnum {
  BLOCK
  CHANNEL
}

type Mutation {
  accept_channel_transfer(input: AcceptChannelTransferInput!): AcceptChannelTransferPayload
  accept_invitation(input: AcceptInvitationInput!): AcceptInvitationPayload
  add_channel_members(input: AddChannelMembersInput!): AddChannelMembersPayload
  add_collaborators(input: AddCollaboratorInput!): AddCollaboratorPayload @deprecated(reason: "Use `add_channel_member` instead")
  add_credit_card(input: AddCreditCardInput!): AddCreditCardPayload
  add_group_users(input: AddGroupUsersInput!): AddGroupUsersPayload
  cancel_channel_transfer(input: CancelChannelTransferInput!): CancelChannelTransferPayload
  cancel_premium_subscription(input: CancelPremiumSubscriptionInput!): CancelPremiumSubscriptionPayload
  clear_notifications(input: ClearNotificationsInput!): ClearNotificationsPayload
  create_authenticated_service(input: CreateAuthenticatedServiceInput!): CreateAuthenticatedServicePayload
  create_block(input: CreateBlockInput!): CreateBlockPayload
  create_channel(input: CreateChannelInput!): CreateChannelPayload
  create_comment(input: CreateCommentInput!): CreateCommentPayload
  create_connection(input: CreateConnectionInput!): CreateConnectionPayload
  create_group(input: CreateGroupInput!): CreateGroupPayload
  create_user_message_channel(input: CreateUserMessageChannelInput!): CreateUserMessageChannelPayload
  delete_authenticated_service(input: DeleteAuthenticatedServiceInput!): DeleteAuthenticatedServicePayload
  delete_channel(input: DeleteChannelInput!): DeleteChannelPayload
  delete_connection(input: DeleteConnectionInput!): DeleteConnectionPayload
  delete_group(input: DeleteGroupInput!): DeleteGroupPayload
  export_channel(input: ExportChannelInput!): ExportChannelPayload
  follow(input: FollowInput!): FollowPayload
  initiate_channel_transfer(input: InitiateChannelTransferInput!): InitiateChannelTransferPayload
  invite_collaborator(input: InviteCollaboratorInput!): InviteCollaboratorPayload @deprecated(reason: "Use `invite_channel_member` instead")
  invite_group_users(input: InviteGroupUsersInput!): InviteGroupUsersPayload
  invite_users(input: InviteUsersInput!): InviteUsersPayload
  login(input: LoginInput!): LoginPayload
  mute(input: MuteInput!): MutePayload
  mute_channel(input: MuteChannelInput!): MuteChannelPayload @deprecated(reason: "Use `mute` instead")
  read_notification(input: ReadNotificationInput!): ReadNotificationPayload
  registration(input: RegistrationInput!): RegistrationPayload
  reject_channel_transfer(input: RejectChannelTransferInput!): RejectChannelTransferPayload
  remove_channel_members(input: RemoveChannelMembersInput!): RemoveChannelMembersPayload
  remove_collaborators(input: RemoveCollaboratorInput!): RemoveCollaboratorPayload @deprecated(reason: "Use `remove_channel_member` instead")
  remove_connection(input: RemoveConnectionInput!): RemoveConnectionPayload
  remove_credit_card(input: RemoveCreditCardInput!): RemoveCreditCardPayload
  remove_group_users(input: RemoveGroupUsersInput!): RemoveGroupUsersPayload
  request_password_reset(input: RequestPasswordResetInput!): RequestPasswordResetPayload
  reset_password(input: ResetPasswordInput!): ResetPasswordPayload
  set_me_flags(input: SetMeFlagsInput!): SetMeFlagsPayload
  share_channel(input: ShareChannelInput!): ShareChannelPayload
  subscribe_to_premium(input: SubscribeToPremiumInput!): SubscribeToPremiumPayload
  unfollow(input: UnfollowInput!): UnfollowPayload
  unmute(input: UnmuteInput!): UnmutePayload
  unmute_channel(input: UnmuteChannelInput!): UnmuteChannelPayload @deprecated(reason: "Use `unmute` instead")
  update_account(input: UpdateAccountInput!): UpdateAccountPayload
  update_block(input: UpdateBlockInput!): UpdateBlockPayload
  update_channel(input: UpdateChannelInput!): UpdateChannelPayload
  update_customer(input: UpdateCustomerInput!): UpdateCustomerPayload
  update_flag(input: UpdateFlagInput!): UpdateFlagPayload @deprecated(reason: "Use `set_me_flags` instead")
  update_group(input: UpdateGroupInput!): UpdateGroupPayload
}

# Autogenerated input type of MuteChannel
input MuteChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of MuteChannel
type MuteChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of Mute
input MuteInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  type: MutableTypeEnum!
}

# Autogenerated return type of Mute
type MutePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  mutable: MutableType
}

# An empty object
type Null {
  is_null: Boolean
}

# Object types for scoped search results
enum ObjectType {
  CHANNEL
  USER
}

# A block which has not yet found its calling
type PendingBlock implements Block & Model {
  can: BlockCan
  counts: BlockCounts
  created_at(format: String, relative: Boolean): String
  id: Int
  remote_source_url: String
  source_title: String
  source_url: String
  updated_at(format: String, relative: Boolean): String
}

type Plan {
  # USD cents
  amount: Float
  external_id: String
  id: ID
  is_hidden: Boolean
  period_end_at(format: String, relative: Boolean): String
  period_start_at(format: String, relative: Boolean): String
  term: String
}

# A policy
type Policy {
  AWSAccessKeyId: String
  acl: String
  bucket: String
  expires: String
  key: String
  policy: String
  signature: String
  success_action_status: String
}

type PremiumSubscription {
  canceled_at(format: String, relative: Boolean): String
  current_period_end_at(format: String, relative: Boolean): String
  current_period_start_at(format: String, relative: Boolean): String
  id: ID
  is_canceled: Boolean
  plan: Plan
  plan_id: String
}

# The query root for this schema
type Query {
  block(id: ID!): Connectable @deprecated(reason: "Use `blokk` until this can be replaced with it")
  blokk(id: ID!): Konnectable

  # A single channel
  channel(id: ID!): Channel

  # Multiple channels
  channels(ids: [ID]!): [Channel]
  coupon(code: String!): Coupon
  explore(direction: Directions = DESC, page: Int = 1, per: Int = 1, sort_by: SearchSorts = null, type: SearchType): [SearchResult]

  # Interface for getting the follow status of users or channels
  followable(id: ID, type: FollowableTypeEnum): FollowableType
  group(id: ID!): Group
  identity(id: ID!): Identity

  # Locates the invited user through their invitation token
  invitee(invitation_token: String!): Invitee

  # The current logged in user
  me: Me

  # Interface for getting the mute status of blocks or channels
  mutable(id: ID!, type: MutableTypeEnum!): MutableType

  # Locates the user through their reset password token
  password_resettable_user(reset_password_token: String!): User
  password_token(token: ID!): User
  search(direction: Directions = DESC, object_id: String = null, object_type: ObjectType = null, page: Int = 1, per: Int = 1, q: String! = null, seed: Int = 336, sort_by: SearchSorts = null, type: SearchType = null): [SearchResult]
  searches: Searches

  # Is this endpoint operational?
  status: String

  # A single user
  user(id: ID!): User
}

# Autogenerated input type of ReadNotification
input ReadNotificationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  notification_id: ID!
}

# Autogenerated return type of ReadNotification
type ReadNotificationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deed: Deed
}

# Autogenerated input type of Registration
input RegistrationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
  first_name: String!
  last_name: String!
  password: String!
  password_confirmation: String!
  receive_newsletter: Boolean
  receive_tips_emails: Boolean
}

# Autogenerated return type of Registration
type RegistrationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Autogenerated input type of RejectChannelTransfer
input RejectChannelTransferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  token: String!
}

# Autogenerated return type of RejectChannelTransfer
type RejectChannelTransferPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RemoveChannelMembers
input RemoveChannelMembersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  members: [ChannelMemberInput]!
}

# Autogenerated return type of RemoveChannelMembers
type RemoveChannelMembersPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RemoveCollaborator
input RemoveCollaboratorInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  user_ids: [ID]!
}

# Autogenerated return type of RemoveCollaborator
type RemoveCollaboratorPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RemoveConnection
input RemoveConnectionInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectable_id: ID!
  connectable_type: BaseConnectableTypeEnum!
}

# Autogenerated return type of RemoveConnection
type RemoveConnectionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Autogenerated input type of RemoveCreditCard
input RemoveCreditCardInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: String!
}

# Autogenerated return type of RemoveCreditCard
type RemoveCreditCardPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  customer: Customer
}

# Autogenerated input type of RemoveGroupUsers
input RemoveGroupUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  user_ids: [ID]!
}

# Autogenerated return type of RemoveGroupUsers
type RemoveGroupUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Autogenerated input type of RequestPasswordReset
input RequestPasswordResetInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
}

# Autogenerated return type of RequestPasswordReset
type RequestPasswordResetPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String
}

# Autogenerated input type of ResetPassword
input ResetPasswordInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  password: String!
  password_confirmation: String!
  token: String!
}

# Autogenerated return type of ResetPassword
type ResetPasswordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Possible types for search results
union SearchResult = Channel | Connectable | Group | User

# Ways to sort blocks
enum SearchSorts {
  ALPHA
  CREATED_AT
  FOLLOWER_COUNT
  LENGTH
  RANDOM
  UPDATED_AT
}

# Ways to filter search by type
enum SearchType {
  CHANNEL
  CONNECTABLE
  USER
}

type Searches {
  collaborators(limit: Int = 10, query: String!, types: [SearchesCollaboratorsType] = [USER, GROUP]): [Member]
  quick(limit: Int = 10, query: String!): [SearchResult]
}

enum SearchesCollaboratorsType {
  GROUP
  USER
}

# Autogenerated input type of SetMeFlags
input SetMeFlagsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  flags: [MeFlagInput]
}

# Autogenerated return type of SetMeFlags
type SetMeFlagsPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Autogenerated input type of ShareChannel
input ShareChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  enable: Boolean!
  id: ID!
}

# Autogenerated return type of ShareChannel
type ShareChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Ways to sort blocks
enum Sorts {
  CREATED_AT
  POSITION
  UPDATED_AT
}

# Autogenerated input type of SubscribeToPremium
input SubscribeToPremiumInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coupon_code: String
  plan_id: SupportedPlanEnum!

  # Tokenized card from Stripe
  token: String!
}

# Autogenerated return type of SubscribeToPremium
type SubscribeToPremiumPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Subscription plans that are purchaseable by users
enum SupportedPlanEnum {
  MONTHLY
  YEARLY
}

# A text block
type Text implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  content(format: Format, no_links: Boolean = false): String
  counts: BlockCounts
  created_at(format: String, relative: Boolean): String
  description(format: Format, no_links: Boolean = false): String
  href: String
  id: Int
  is_muted: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(format: String, relative: Boolean): String
  user: User
  visibility: String
}

# Autogenerated input type of Unfollow
input UnfollowInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  type: FollowableTypeEnum!
}

# Autogenerated return type of Unfollow
type UnfollowPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  followable: FollowableType
}

# Autogenerated input type of UnmuteChannel
input UnmuteChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of UnmuteChannel
type UnmuteChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of Unmute
input UnmuteInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  type: MutableTypeEnum!
}

# Autogenerated return type of Unmute
type UnmutePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  mutable: MutableType
}

# Autogenerated input type of UpdateAccount
input UpdateAccountInput {
  bio: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String
  exclude_from_indexes: Boolean
  first_name: String
  home_path: String
  last_name: String
  receive_email: String
  receive_newsletter: Boolean
  show_tour: Boolean
}

# Autogenerated return type of UpdateAccount
type UpdateAccountPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Autogenerated input type of UpdateBlock
input UpdateBlockInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  content: String
  description: String
  id: ID!
  title: String
}

# Autogenerated return type of UpdateBlock
type UpdateBlockPayload {
  block: Connectable

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateChannel
input UpdateChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  id: ID!
  title: String
  visibility: ChannelVisibility
}

# Autogenerated return type of UpdateChannel
type UpdateChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateCustomer
input UpdateCustomerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  default_credit_card_id: String
}

# Autogenerated return type of UpdateCustomer
type UpdateCustomerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  customer: Customer
}

# Autogenerated input type of UpdateFlag
input UpdateFlagInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  name: MeFlagsEnum!
  value: Boolean!
}

# Autogenerated return type of UpdateFlag
type UpdateFlagPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  flags: MeFlags
}

# Autogenerated input type of UpdateGroup
input UpdateGroupInput {
  avatar_url: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  id: ID!
  name: String
}

# Autogenerated return type of UpdateGroup
type UpdateGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# A single user
type User implements Followable & Model & UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan

  # Special channel field that eager loads all the owner and does not do pagination
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]
  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Connectable]
  counts: UserCounts
  created_at(format: String, relative: Boolean): String
  first_name: String
  followers(page: Int = 1, per: Int = 1): [User]
  following(page: Int = 1, per: Int = 1): [FollowableType]
  groups(page: Int = 1, per: Int = 1): [Group]
  hidden_email: String
  href(absolute: Boolean = false): String
  id: Int
  initials: String
  is_followed: Boolean
  is_indexable: Boolean
  is_investor: Boolean
  is_me: Boolean
  is_premium: Boolean
  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]
  last_name: String
  name: String
  slug: String
  updated_at(format: String, relative: Boolean): String
}

# The actions that the CurrentUser can perform on the User
type UserCan {
  follow: Boolean
  manage: Boolean
  message: Boolean
}

type UserCounts implements UserCountsInterface {
  blocks: Int
  channels: Int
  connections: Int
  followers: Int
  following: Int
  groups: Int
}

interface UserCountsInterface {
  blocks: Int
  channels: Int
  connections: Int
  followers: Int
  following: Int
  groups: Int
}

# Fields common to all users
interface UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan

  # Special channel field that eager loads all the owner and does not do pagination
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels]
  contents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Connectable]
  first_name: String
  following(page: Int = 1, per: Int = 1): [FollowableType]
  groups(page: Int = 1, per: Int = 1): [Group]
  hidden_email: String
  href(absolute: Boolean = false): String
  initials: String
  is_indexable: Boolean
  is_investor: Boolean
  is_me: Boolean
  is_premium: Boolean
  kontents(direction: Directions = DESC, page: Int = 1, per: Int = 1, q: String = null, seed: Int = 336, sort_by: SearchSorts = UPDATED_AT, type: ConnectableTypeEnum = null): [Konnectable]
  last_name: String
  name: String
  slug: String
}